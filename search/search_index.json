{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Projeto Platforms, Microservices, DevOps and APIs - 2025.1","text":"<p>Bem-vindo ao projeto da disciplina. Este reposit\u00f3rio documenta o desenvolvimento de solu\u00e7\u00f5es com microservi\u00e7os, pr\u00e1ticas de DevOps e implanta\u00e7\u00e3o em nuvem usando Kubernetes (Minikube e AWS EKS).</p>"},{"location":"#repositorio-de-microservicos","title":"Reposit\u00f3rio de Microservi\u00e7os","text":"<p>Todos os microservi\u00e7os e artefatos de infraestrutura est\u00e3o dispon\u00edveis neste reposit\u00f3rio: https://github.com/gabrielfmendesm/microservicos (No README desse reposit\u00f3rio constam os links para todos os microservi\u00e7os individuais da aplica\u00e7\u00e3o.)</p>"},{"location":"#integrantes-do-grupo","title":"Integrantes do Grupo","text":"<ul> <li>Gabriel Mendes</li> <li>Henrique Turco</li> </ul>"},{"location":"#estrutura-geral","title":"Estrutura Geral","text":"<ul> <li>Projeto em Grupo: Envolve como os microservi\u00e7os foram integrados, quais tecnologias de infraestrutura foram utilizadas e como o sistema foi implantado em ambiente de produ\u00e7\u00e3o com AWS EKS.  </li> <li>Projeto Individual: Cada integrante desenvolveu microservi\u00e7os isoladamente, seguindo especifica\u00e7\u00f5es de APIs REST autenticadas e integradas ao gateway. Cada servi\u00e7o incluiu endpoints funcionais, consumo de APIs externas, deploy com Minikube e EKS, al\u00e9m de pr\u00e1ticas de DevOps como CI/CD, monitoramento e tratamento de erros. As entregas individuais envolveram tamb\u00e9m documenta\u00e7\u00e3o completa com evid\u00eancias e v\u00eddeo de demonstra\u00e7\u00e3o.</li> </ul>"},{"location":"#agradecimentos","title":"Agradecimentos","text":"<p>Agradecemos \u00e0 equipe docente da disciplina e ao suporte t\u00e9cnico fornecido para o desenvolvimento do projeto.</p> <p>Documenta\u00e7\u00e3o desenvolvida para fins acad\u00eamicos - Insper 2025.1.</p>"},{"location":"projeto/","title":"Projeto em Grupo","text":""},{"location":"projeto/#visao-geral-do-projeto","title":"Vis\u00e3o Geral do Projeto","text":"<p>O projeto em grupo tem como objetivo aplicar pr\u00e1ticas modernas de desenvolvimento em nuvem, DevOps e microservi\u00e7os em um ambiente real de produ\u00e7\u00e3o usando a AWS. As entregas foram organizadas em etapas pr\u00e1ticas que abrangem desde a configura\u00e7\u00e3o da infraestrutura (AWS e EKS), testes de desempenho (HPA e carga), at\u00e9 o deploy automatizado com Jenkins (CI/CD). Al\u00e9m disso, cada grupo foi respons\u00e1vel por realizar uma an\u00e1lise de custos realista utilizando o AWS Pricing Calculator e calcular o uso de recursos com base em seu cluster. A entrega final inclui n\u00e3o apenas a implanta\u00e7\u00e3o funcional da aplica\u00e7\u00e3o via EKS e banco de dados com RDS, mas tamb\u00e9m a documenta\u00e7\u00e3o completa, uma apresenta\u00e7\u00e3o de storytelling visual e um v\u00eddeo de demonstra\u00e7\u00e3o entre 2 a 3 minutos. O projeto avalia tanto aspectos t\u00e9cnicos quanto de comunica\u00e7\u00e3o, destacando desafios enfrentados e pr\u00e1ticas de engenharia adotadas, como o uso de PaaS, testes de carga e automatiza\u00e7\u00e3o de pipelines. Cada etapa do projeto contribui para uma forma\u00e7\u00e3o s\u00f3lida em arquitetura de sistemas distribu\u00eddos, cloud computing e entrega cont\u00ednua.</p>"},{"location":"projeto/#objetivos","title":"Objetivos","text":"<ul> <li>Configurar a conta AWS para suportar o projeto.</li> <li>Provisionar e configurar corretamente o cluster EKS.</li> <li>Elaborar um plano de custos realista utilizando o AWS Pricing Calculator.</li> <li>Aplicar solu\u00e7\u00f5es PaaS para simplificar opera\u00e7\u00f5es (RDS, EKS, ECR).</li> <li>Garantir que todos os microservi\u00e7os estejam funcionando corretamente no ambiente de produ\u00e7\u00e3o.</li> </ul>"},{"location":"projeto/#arquitetura","title":"Arquitetura","text":"<ul> <li>API Gateway: Controla entrada e roteamento.</li> <li>Auth: Servi\u00e7o de autentica\u00e7\u00e3o com JWT.</li> <li>Exchange, Product, Order, Account: servi\u00e7os de dom\u00ednio.</li> <li>PostgreSQL: banco de dados usado pelos servi\u00e7os.</li> </ul>"},{"location":"projeto/#fluxo-de-requisicao","title":"Fluxo de requisi\u00e7\u00e3o","text":"<ol> <li>Login no Auth \u2192 recebe token JWT  </li> <li>Token usado no Gateway para acessar rotas protegidas  </li> <li>Gateway redireciona para Account, Order ou Product  </li> </ol>"},{"location":"projeto/#deploy","title":"Deploy","text":"<ul> <li>Minikube: usado em testes locais  </li> <li>EKS: usado na apresenta\u00e7\u00e3o final  </li> </ul> <p>Toda a infraestrutura foi gerenciada com <code>kubectl</code>, arquivos YAML e Helm quando aplic\u00e1vel.</p>"},{"location":"projeto/#configuracao-aws-e-eks","title":"Configura\u00e7\u00e3o AWS e EKS","text":"<p>Durante este projeto, n\u00f3s configuramos a conta AWS e provisionamos um cluster EKS. Abaixo, uma captura de tela do cluster em execu\u00e7\u00e3o:</p> <p></p> <p>Este cluster foi configurado para escalar automaticamente conforme a demanda usando Auto Scaling Groups e HPA.</p> <p>Endpoint da API em execu\u00e7\u00e3o: <pre><code>http://aef1f8f294b95439283d49dcde0dbde5-1733067101.sa-east-1.elb.amazonaws.com\n</code></pre></p>"},{"location":"projeto/#analise-de-custos","title":"An\u00e1lise de Custos","text":"<p>Utilizamos o AWS Pricing Calculator para gerar um plano de custo que reflete o uso estimado dos recursos no EKS:</p> <p></p> <p>A proje\u00e7\u00e3o acima demonstra os custos mensais esperados para manter o ambiente dormindo e em uso.</p>"},{"location":"projeto/#paas","title":"PaaS","text":"<p>A plataforma como servi\u00e7o (PaaS) \u00e9 um modelo de computa\u00e7\u00e3o em nuvem que fornece uma plataforma para desenvolver, executar e gerenciar aplicativos sem a complexidade de construir e manter a infraestrutura normalmente associada ao desenvolvimento e lan\u00e7amento de aplicativos.</p> <p></p> <p>Durante o desenvolvimento, utilizamos PaaS da AWS de v\u00e1rias formas:</p> <ol> <li>Amazon Relational Database Service (RDS)</li> <li>O servi\u00e7o de banco de dados PostgreSQL foi gerenciado pelo RDS, eliminando a necessidade de configurar e manter servidores de banco de dados.</li> <li> <p>Configuramos par\u00e2metros de backup e alta disponibilidade diretamente na console do RDS, garantindo persist\u00eancia e durabilidade dos dados.</p> </li> <li> <p>Amazon Elastic Kubernetes Service (EKS)</p> </li> <li>Embora o EKS seja considerado um servi\u00e7o gerenciado de Kubernetes (conhecido como Kubernetes como servi\u00e7o), ele tamb\u00e9m se encaixa no modelo PaaS pois a AWS gerencia o plano de controle do cluster.</li> <li> <p>Utilizamos o EKS para orquestrar os microservi\u00e7os sem precisar provisionar a inst\u00e2ncia do plano mestre nem gerenciar upgrades de vers\u00e3o do Kubernetes manualmente.</p> </li> <li> <p>Amazon Elastic Container Registry (ECR)</p> </li> <li>Em vez de hospedar um reposit\u00f3rio Docker local ou auto-hospedado, utilizamos o ECR para versionar e armazenar as imagens dos microservi\u00e7os.</li> <li>As pipelines do Jenkins fazem o push das imagens diretamente para o ECR, que oferece integra\u00e7\u00e3o nativa com o EKS.</li> <li>Com o ECR, n\u00e3o precisamos configurar servidores extras para registros de container.</li> </ol> <p>Essas escolhas de PaaS reduziram o overhead operacional e permitiram que foc\u00e1ssemos em codifica\u00e7\u00e3o, monitora\u00e7\u00e3o e escalabilidade do cluster EKS.</p>"},{"location":"projeto/#video-de-demonstracao","title":"V\u00eddeo de Demonstra\u00e7\u00e3o","text":"<p>A seguir, nosso v\u00eddeo de demonstra\u00e7\u00e3o, mostrando o projeto em funcionamento:</p> <p> Clique na imagem acima para ver o v\u00eddeo.</p>"},{"location":"individual/exchange/","title":"Exchange API","text":"<p>A Exchange API foi desenvolvida em FastAPI (Python) para oferecer convers\u00e3o de moeda via um endpoint REST. As cota\u00e7\u00f5es s\u00e3o obtidas em tempo real na ExchangeRate-API.</p>"},{"location":"individual/exchange/#endpoint","title":"Endpoint","text":"M\u00e9todo Rota Descri\u00e7\u00e3o <code>GET</code> <code>/exchange/{from}/{to}</code> Converte da moeda {from} para {to} (ISO-4217)."},{"location":"individual/exchange/#parametros-de-caminho","title":"Par\u00e2metros de caminho","text":"Par\u00e2metro Exemplo Descri\u00e7\u00e3o <code>from</code> <code>USD</code> C\u00f3digo ISO-4217 da moeda de origem <code>to</code> <code>EUR</code> C\u00f3digo ISO-4217 da moeda de destino"},{"location":"individual/exchange/#exemplo-de-resposta","title":"Exemplo de resposta","text":"<pre><code>{\n  \"sell\": 0.82,\n  \"buy\" : 0.80,\n  \"date\": \"2021-09-01T14:23:42Z\",\n  \"id-account\": \"0195ae95-5be7-7dd3-b35d-7a7d87c404fb\"\n}\n</code></pre> <ul> <li>sell: taxa de venda (quanto a API vende 1 unidade de <code>from</code> em <code>to</code>).  </li> <li>buy: taxa de compra (quanto a API compra 1 unidade de <code>from</code> em <code>to</code>).  </li> <li>date: data e hora da cota\u00e7\u00e3o (formato ISO 8601).  </li> <li>id-account: identificador da conta que fez a requisi\u00e7\u00e3o (UUID).  </li> </ul>"},{"location":"individual/exchange/#diagrama-de-integracao-com-gateway","title":"Diagrama de Integra\u00e7\u00e3o com Gateway","text":""},{"location":"individual/exchange/#teste-da-rota-com-postman","title":"Teste da Rota com Postman","text":"<p>Abaixo segue um exemplo de requisi\u00e7\u00e3o ao endpoint <code>/exchange/USD/EUR</code> no Postman, exibindo o retorno das taxas de c\u00e2mbio:</p> <p></p>"},{"location":"individual/jenkins/","title":"Jenkins","text":"<p>Nesta fase do projeto, o objetivo era criar pipelines no Jenkins, conectando cada reposit\u00f3rio de microsservi\u00e7o para automatizar o build e a publica\u00e7\u00e3o das imagens Docker.</p>"},{"location":"individual/jenkins/#interface-jenkins","title":"Interface Jenkins","text":"<p>A seguir, temos a vis\u00e3o geral da interface do Jenkins com os jobs configurados:</p> <p>Dashboard do Jenkins </p> <p>Cada servi\u00e7o (interface ou service) foi adicionado como um pipeline separado.</p>"},{"location":"individual/jenkins/#credencial-docker-hub","title":"Credencial Docker Hub","text":"<p>Para permitir o push autom\u00e1tico de imagens Docker, foi configurada uma credencial do tipo Username + Password com o ID <code>dockerhub-credential</code>, conforme a imagem abaixo:</p> <p>Credential configurada </p>"},{"location":"individual/jenkins/#jenkinsfile-interfaces","title":"Jenkinsfile (Interfaces)","text":"<p>As interfaces (como <code>product</code>, <code>order</code>, <code>account</code>) utilizam um Jenkinsfile simples para build Maven:</p> <pre><code>pipeline {\n    agent any\n\n    stages {\n        stage('Build') {\n            steps {\n                sh 'mvn -B -DskipTests clean install'\n            }\n        }\n    }\n}\n</code></pre> <p>Este pipeline compila o c\u00f3digo e garante que as depend\u00eancias estejam corretas, mas n\u00e3o realiza deploy de imagens.</p>"},{"location":"individual/jenkins/#jenkinsfile-services","title":"Jenkinsfile (Services)","text":"<p>Para os services (como <code>order-service</code>, <code>product-service</code>, etc.), o Jenkinsfile realiza tamb\u00e9m o build da imagem Docker e seu push para o Docker Hub:</p> <pre><code>pipeline {\n    agent any\n    environment {\n        SERVICE = 'order'\n        NAME = \"gabrielfmendesm/${env.SERVICE}\"\n    }\n    stages {\n        stage('Dependecies') {\n            steps {\n                build job: 'order', wait: true\n            }\n        }\n        stage('Build') {\n            steps {\n                sh 'mvn -B -DskipTests clean package'\n            }\n        }\n        stage('Build &amp; Push Image') {\n            steps {\n                withCredentials([usernamePassword(credentialsId: 'dockerhub-credential', usernameVariable: 'USERNAME', passwordVariable: 'TOKEN')]) {\n                    sh \"docker login -u $USERNAME -p $TOKEN\"\n                    sh \"docker buildx create --use --platform=linux/arm64,linux/amd64 --node multi-platform-builder-${env.SERVICE} --name multi-platform-builder-${env.SERVICE}\"\n                    sh \"docker buildx build --platform=linux/arm64,linux/amd64 --push --tag ${env.NAME}:latest --tag ${env.NAME}:${env.BUILD_ID} -f Dockerfile .\"\n                    sh \"docker buildx rm --force multi-platform-builder-${env.SERVICE}\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Esse pipeline compila, empacota, constr\u00f3i e publica a imagem usando multi-platform Docker build.</p>"},{"location":"individual/minikube/","title":"MiniKube","text":""},{"location":"individual/minikube/#objetivo","title":"Objetivo","text":"<p>Este guia descreve como executar todos os microservi\u00e7os em um cluster Kubernetes local usando o Minikube, simulando um ambiente de orquestra\u00e7\u00e3o completo em sua m\u00e1quina de desenvolvimento.</p>"},{"location":"individual/minikube/#pre-requisitos","title":"Pr\u00e9-Requisitos","text":"<ul> <li>Docker instalado e em execu\u00e7\u00e3o  </li> <li>Minikube instalado (vers\u00e3o recomendada: &gt;= 1.0)  </li> <li>kubectl instalado e configurado para se comunicar com o Minikube  </li> <li>Privilegios de sudo (caso seja necess\u00e1rio para o uso de determinadas funcionalidades)</li> </ul>"},{"location":"individual/minikube/#passos-para-iniciar","title":"Passos para Iniciar","text":""},{"location":"individual/minikube/#1-iniciar-o-minikube","title":"1. Iniciar o Minikube","text":"<p>No terminal, execute:</p> <pre><code>minikube start --driver=docker\n</code></pre> <p>O exemplo acima utiliza o driver Docker, mas voc\u00ea pode substitu\u00ed-lo por outro (como \u201cvirtualbox\u201d ou \u201chyperkit\u201d) conforme sua configura\u00e7\u00e3o local. Para mais detalhes, consulte a documenta\u00e7\u00e3o oficial do Minikube.</p> <p>Aguarde at\u00e9 que o Minikube fa\u00e7a o download da imagem base, inicie uma VM (ou container) e configure o cluster local.</p>"},{"location":"individual/minikube/#2-clonar-e-navegar-ate-o-projeto","title":"2. Clonar e Navegar at\u00e9 o Projeto","text":"<pre><code># Exemplo de comando para clonar o reposit\u00f3rio, se ainda n\u00e3o tiver feito:\ngit clone https://github.com/seu-usuario/seu-projeto.git\ncd seu-projeto/platforma/api/k8s\n</code></pre> <p>No diret\u00f3rio <code>k8s/</code>, voc\u00ea encontrar\u00e1 arquivos YAML para cada microservi\u00e7o:</p> <ul> <li><code>account-service</code></li> <li><code>auth-service</code></li> <li><code>exchange-service</code></li> <li><code>gateway-service</code></li> <li><code>order-service</code></li> <li><code>product-service</code></li> <li><code>postgres-service</code></li> </ul>"},{"location":"individual/minikube/#3-aplicar-todos-os-manifests","title":"3. Aplicar Todos os Manifests","text":"<p>Para criar todos os recursos de uma s\u00f3 vez, rode:</p> <pre><code>kubectl apply -f .\n</code></pre> <p>Este comando processa todos os arquivos <code>.yaml</code> (ou <code>.yml</code>) do diret\u00f3rio atual, criando Deployments, Services, ConfigMaps, Secrets etc.</p>"},{"location":"individual/minikube/#4-verificar-status","title":"4. Verificar Status","text":""},{"location":"individual/minikube/#41-pods","title":"4.1. Pods","text":"<p><pre><code>kubectl get pods\n</code></pre> O retorno esperado deve ser semelhante a:</p> <pre><code>$ kubectl get pods\nNAME                                READY   STATUS    RESTARTS   AGE\naccount-service-XXXXXXXXXX-XXXXX    1/1     Running   0          10m\nauth-service-XXXXXXXXXX-XXXXX       1/1     Running   0          10m\n...\npostgres-service-XXXXXXXXXX-XXXXX   1/1     Running   0          10m\n</code></pre> <p></p> <p>Verifique se todos os pods est\u00e3o com o STATUS Running e sem erros. Caso algum esteja com STATUS CrashLoopBackOff ou Error, inspecione os logs:</p> <pre><code>kubectl logs &lt;nome-do-pod&gt;\n</code></pre>"},{"location":"individual/minikube/#42-servicos","title":"4.2. Servi\u00e7os","text":"<pre><code>kubectl get svc\n</code></pre> <p>Confira se cada servi\u00e7o (Service) est\u00e1 exposto corretamente e possui o Cluster-IP ou NodePort configurado.</p> <pre><code>$ kubectl get svc\nNAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE\naccount-service    ClusterIP   10.96.0.10      &lt;none&gt;        8080/TCP         10m\nauth-service       ClusterIP   10.96.0.11      &lt;none&gt;        8080/TCP         10m\ngateway-service    ClusterIP   10.96.0.12      &lt;none&gt;        80/TCP           10m\n...\n</code></pre> <p></p>"},{"location":"individual/minikube/#acessando-a-aplicacao","title":"Acessando a Aplica\u00e7\u00e3o","text":""},{"location":"individual/minikube/#5-acessar-um-servico-via-navegador","title":"5. Acessar um Servi\u00e7o via Navegador","text":"<p>Se quiser expor um servi\u00e7o (por exemplo, o gateway-service) localmente, utilize:</p> <pre><code>minikube service gateway-service\n</code></pre> <p>O Minikube criar\u00e1 automaticamente um t\u00fanel tempor\u00e1rio e abrir\u00e1 o servi\u00e7o no navegador. Caso n\u00e3o abra automaticamente, ser\u00e1 exibido o URL que pode ser acessado manualmente.</p> <p>\u26a0\ufe0f Dica: Em alguns sistemas, pode ser necess\u00e1rio usar <code>minikube tunnel</code> em outro terminal para expor servi\u00e7os do tipo LoadBalancer.</p>"},{"location":"individual/minikube/#arquitetura-do-diretorio-k8s","title":"Arquitetura do Diret\u00f3rio <code>k8s/</code>","text":"<pre><code>k8s/\n\u251c\u2500 account-service.yaml\n\u251c\u2500 auth-service.yaml\n\u251c\u2500 configmap.yaml\n\u251c\u2500 deployment.yaml\n\u251c\u2500 gateway-service.yaml\n\u251c\u2500 order-service.yaml\n\u251c\u2500 product-service.yaml\n\u251c\u2500 redis.yaml\n\u251c\u2500 secrets.yaml\n\u2514\u2500 service.yaml\n</code></pre> <ul> <li>Cada microservi\u00e7o cont\u00e9m um arquivo <code>k8s.yaml</code> que define o Deployment e o Service.</li> <li>O servi\u00e7o do <code>postgres</code> possui ConfigMap, Secrets, Deployment e Service separados para maior flexibilidade.</li> </ul>"},{"location":"individual/order/","title":"Order API","text":"<p>O Order API foi desenvolvido em Spring Boot (Java) e fornece um conjunto de endpoints REST para gerenciar pedidos de uma loja. Todas as requisi\u00e7\u00f5es passam pelo API Gateway, que valida o token JWT antes de encaminhar ao servi\u00e7o.</p>"},{"location":"individual/order/#endpoints-principais","title":"Endpoints Principais","text":""},{"location":"individual/order/#criar-novo-pedido","title":"Criar novo pedido","text":"<ul> <li>M\u00e9todo: <code>POST</code></li> <li>Rota: <code>/order</code></li> <li>Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre></li> <li>Request Body (JSON):   <pre><code>{\n  \"items\": [\n    {\n      \"idProduct\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\",\n      \"quantity\": 2\n    },\n    {\n      \"idProduct\": \"0195abfe-e416-7052-be3b-27cdaf12a984\",\n      \"quantity\": 1\n    }\n  ]\n}\n</code></pre></li> <li>Response (JSON \u2014 c\u00f3digo HTTP 201 Created):   <pre><code>{\n  \"id\": \"0195ac33-73e5-7cb3-90ca-7b5e7e549569\",\n  \"date\": \"2025-09-01T12:30:00\",\n  \"items\": [\n    {\n      \"id\": \"01961b9a-bca2-78c4-9be1-7092b261f217\",\n      \"product\": {\n        \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\"\n      },\n      \"quantity\": 2,\n      \"total\": 20.24\n    },\n    {\n      \"id\": \"01961b9b-08fd-76a5-8508-cdb6cd5c27ab\",\n      \"product\": {\n        \"id\": \"0195abfe-e416-7052-be3b-27cdaf12a984\"\n      },\n      \"quantity\": 10,\n      \"total\": 6.2\n    }\n  ],\n  \"total\": 26.44\n}\n</code></pre></li> </ul>"},{"location":"individual/order/#listar-todos-os-pedidos","title":"Listar todos os pedidos","text":"<ul> <li>M\u00e9todo: <code>GET</code></li> <li>Rota: <code>/order</code></li> <li>Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre></li> <li>Response (JSON Array \u2014 c\u00f3digo HTTP 200 OK):   <pre><code>[\n  {\n    \"id\": \"0195ac33-73e5-7cb3-90ca-7b5e7e549569\",\n    \"date\": \"2025-09-01T12:30:00\",\n    \"total\": 26.44\n  },\n  {\n    \"id\": \"0195ac33-cbbd-7a6e-a15b-b85402cf143f\",\n    \"date\": \"2025-10-09T03:21:57\",\n    \"total\": 18.6\n  }\n]\n</code></pre></li> </ul>"},{"location":"individual/order/#obter-pedido-por-id","title":"Obter pedido por ID","text":"<ul> <li>M\u00e9todo: <code>GET</code></li> <li>Rota: <code>/order/{id}</code></li> <li>Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre></li> <li>Response (JSON \u2014 c\u00f3digo HTTP 200 OK):   <pre><code>{\n  \"id\": \"0195ac33-73e5-7cb3-90ca-7b5e7e549569\",\n  \"date\": \"2025-09-01T12:30:00\",\n  \"items\": [\n    {\n      \"id\": \"01961b9a-bca2-78c4-9be1-7092b261f217\",\n      \"product\": {\n        \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\"\n      },\n      \"quantity\": 2,\n      \"total\": 20.24\n    },\n    {\n      \"id\": \"01961b9b-08fd-76a5-8508-cdb6cd5c27ab\",\n      \"product\": {\n        \"id\": \"0195abfe-e416-7052-be3b-27cdaf12a984\"\n      },\n      \"quantity\": 10,\n      \"total\": 6.2\n    }\n  ],\n  \"total\": 26.44\n}\n</code></pre></li> <li>Caso o pedido n\u00e3o exista: retorna 404 Not Found com corpo vazio.</li> </ul>"},{"location":"individual/order/#autenticacao","title":"Autentica\u00e7\u00e3o","text":"<ul> <li>Todas as chamadas aos endpoints acima exigem um token JWT v\u00e1lido.</li> <li>O token deve ser produzido pelo Auth Service e passado no cabe\u00e7alho:   <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre></li> </ul>"},{"location":"individual/order/#diagrama-de-integracao-com-o-gateway","title":"Diagrama de Integra\u00e7\u00e3o com o Gateway","text":""},{"location":"individual/order/#testes-das-rotas-com-postman","title":"Testes das Rotas com Postman","text":"<p>Teste com cria\u00e7\u00e3o de um pedido </p> <p>Teste para ver todos os pedidos cadastrados </p> <p>Teste para ver um pedido cadastrado espec\u00edfico </p>"},{"location":"individual/product/","title":"Product API","text":"<p>A Product API foi desenvolvida em Spring Boot (Java) e fornece um conjunto de endpoints REST para gerenciar produtos de uma loja. Todas as requisi\u00e7\u00f5es passam pelo API Gateway, que valida o token JWT antes de encaminhar ao servi\u00e7o.</p>"},{"location":"individual/product/#endpoints-principais","title":"Endpoints Principais","text":""},{"location":"individual/product/#criar-novo-produto","title":"Criar novo produto","text":"<ul> <li>M\u00e9todo: <code>POST</code> </li> <li>Rota: <code>/product</code> </li> <li>Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre></li> <li>Request Body (JSON):   <pre><code>{\n  \"name\": \"Tomate\",\n  \"price\": 10.12,\n  \"unit\": \"kg\"\n}\n</code></pre></li> <li>Response (JSON \u2014 c\u00f3digo HTTP 201 Created):   <pre><code>{\n  \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\",\n  \"name\": \"Tomate\",\n  \"price\": 10.12,\n  \"unit\": \"kg\"\n}\n</code></pre></li> </ul>"},{"location":"individual/product/#listar-todos-os-produtos","title":"Listar todos os produtos","text":"<ul> <li>M\u00e9todo: <code>GET</code> </li> <li>Rota: <code>/product</code> </li> <li>Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre></li> <li>Response (JSON Array \u2014 c\u00f3digo HTTP 200 OK):   <pre><code>[\n  {\n    \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\",\n    \"name\": \"Tomate\",\n    \"price\": 10.12,\n    \"unit\": \"kg\"\n  },\n  {\n    \"id\": \"0195abfe-e416-7052-be3b-27cdaf12a984\",\n    \"name\": \"Ma\u00e7\u00e3\",\n    \"price\": 8.57,\n    \"unit\": \"kg\"\n  }\n]\n</code></pre></li> </ul>"},{"location":"individual/product/#obter-produto-por-id","title":"Obter produto por ID","text":"<ul> <li>M\u00e9todo: <code>GET</code> </li> <li>Rota: <code>/product/{id}</code> </li> <li>Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre></li> <li>Response (JSON \u2014 c\u00f3digo HTTP 200 OK):   <pre><code>{\n  \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\",\n  \"name\": \"Tomate\",\n  \"price\": 10.12,\n  \"unit\": \"kg\"\n}\n</code></pre></li> <li>Caso o produto n\u00e3o exista: retorna 404 Not Found com corpo vazio.</li> </ul>"},{"location":"individual/product/#deletar-produto-por-id","title":"Deletar produto por ID","text":"<ul> <li>M\u00e9todo: <code>DELETE</code> </li> <li>Rota: <code>/product/{id}</code> </li> <li>Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre></li> <li>Response:</li> <li>204 No Content se o produto existir e for removido com sucesso.</li> <li>404 Not Found se n\u00e3o encontrar o produto.</li> </ul>"},{"location":"individual/product/#autenticacao","title":"Autentica\u00e7\u00e3o","text":"<ul> <li>Todas as chamadas aos endpoints acima exigem um token JWT v\u00e1lido.  </li> <li>O token deve ser produzido pelo Auth Service e passado no cabe\u00e7alho:   <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre></li> </ul>"},{"location":"individual/product/#diagrama-de-integracao-com-o-gateway","title":"Diagrama de Integra\u00e7\u00e3o com o Gateway","text":""},{"location":"individual/product/#testes-das-rotas-com-postman","title":"Testes das Rotas com Postman","text":"<p>A seguir exemplos de requisi\u00e7\u00f5es no Postman para os principais fluxos:</p> <ul> <li> <p>Cria\u00e7\u00e3o de um produto </p> </li> <li> <p>Listagem de todos os produtos </p> </li> <li> <p>Consulta de produto por ID </p> </li> <li> <p>Remo\u00e7\u00e3o de produto por ID </p> </li> </ul>"},{"location":"individual/bottlenecks/cache/","title":"Cache com Redis no Product Service","text":"<p>Implementei o cache usando Redis no microservi\u00e7o Product para melhorar o desempenho e reduzir chamadas ao banco de dados. A seguir, descrevo as principais altera\u00e7\u00f5es que fiz.</p>"},{"location":"individual/bottlenecks/cache/#configuracao-no-minikube","title":"Configura\u00e7\u00e3o no Minikube","text":"<p>Para rodar o Redis junto com os servi\u00e7os, adicionei o arquivo <code>redis.yaml</code> no diret\u00f3rio <code>k8s/</code>. O Deployment e Service ficaram assim:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: redis\n  labels:\n    app: redis\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: redis\n  template:\n    metadata:\n      labels:\n        app: redis\n    spec:\n      containers:\n        - name: redis\n          image: redis:6.2-alpine\n          ports:\n            - containerPort: 6379\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: redis\n  labels:\n    app: redis\nspec:\n  type: ClusterIP\n  selector:\n    app: redis\n  ports:\n    - port: 6379\n      targetPort: 6379\n</code></pre> <p>Depois de aplicar esse <code>redis.yaml</code> com <code>kubectl apply -f k8s/redis.yaml</code>, o Redis ficou dispon\u00edvel no cluster, e pude confirmar com:</p> <pre><code>kubectl get pods\n</code></pre> <p>Que mostrou algo como:</p> <pre><code>NAME                        READY   STATUS    RESTARTS   AGE\n...\nproduct-5cf9d54c89-5fqpv     1/1     Running   0          17m\nredis-66c4bb97fd-6vqqc       1/1     Running   0          17m\n...\n</code></pre>"},{"location":"individual/bottlenecks/cache/#alteracoes-no-applicationyaml","title":"Altera\u00e7\u00f5es no <code>application.yaml</code>","text":"<p>No <code>src/main/resources/application.yaml</code> do Product, a conex\u00e3o com o Redis foi configurada assim:</p> <pre><code>spring:\n  data:\n    redis:\n      host: redis   # nome do Service no Kubernetes\n      port: 6379\n</code></pre> <p>Com isso, o Spring Boot consegue encontrar o Redis pelo servi\u00e7o de DNS interno do cluster.</p>"},{"location":"individual/bottlenecks/cache/#dependencias-adicionais","title":"Depend\u00eancias adicionais","text":"<p>Atualizei o <code>pom.xml</code> para incluir:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Essas depend\u00eancias ativam o suporte a cache e a integra\u00e7\u00e3o com Redis.</p>"},{"location":"individual/bottlenecks/cache/#modificacoes-no-codigo","title":"Modifica\u00e7\u00f5es no c\u00f3digo","text":""},{"location":"individual/bottlenecks/cache/#productapplicationjava","title":"<code>ProductApplication.java</code>","text":"<p>Habilitei o cache adicionando <code>@EnableCaching</code>:</p> <pre><code>package store.product;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cache.annotation.EnableCaching;\n\n@SpringBootApplication\n@EnableCaching\npublic class ProductApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(ProductApplication.class, args);\n  }\n}\n</code></pre>"},{"location":"individual/bottlenecks/cache/#productservicejava","title":"<code>ProductService.java</code>","text":"<p>Implementei anota\u00e7\u00f5es de cache em m\u00e9todos de leitura e limpeza de cache em m\u00e9todos de escrita:</p> <pre><code>package store.product;\n\nimport java.util.List;\nimport java.util.stream.StreamSupport;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.CacheEvict;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.server.ResponseStatusException;\n\n@Service\npublic class ProductService {\n\n    @Autowired\n    private ProductRepository productRepository;\n\n    @CacheEvict(value = \"products\", allEntries = true)\n    public Product create(Product product) {\n        return productRepository.save(new ProductModel(product)).to();\n    }\n\n    @Cacheable(value = \"products\", key = \"#id\")\n    public Product findById(String id) {\n        return productRepository.findById(id)\n            .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, \"Product not found\"))\n            .to();\n    }\n\n    @Cacheable(value = \"products\", key = \"'all'\")\n    public List&lt;Product&gt; findAll() {\n        return StreamSupport.stream(productRepository.findAll().spliterator(), false)\n            .map(ProductModel::to)\n            .toList();\n    }\n\n    @CacheEvict(value = \"products\", allEntries = true)\n    public void deleteById(String id) {\n        if (!productRepository.existsById(id)) {\n            throw new ResponseStatusException(HttpStatus.NOT_FOUND, \"Product not found\");\n        }\n        productRepository.deleteById(id);\n    }\n}\n</code></pre>"},{"location":"individual/bottlenecks/cache/#productjava","title":"<code>Product.java</code>","text":"<p>Para permitir a serializa\u00e7\u00e3o de objetos no cache, tornei a entidade serializ\u00e1vel:</p> <pre><code>package store.product;\n\nimport java.io.Serializable;\n\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.experimental.Accessors;\n\n@Builder\n@Data\n@Accessors(fluent = true)\npublic class Product implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private String id;\n    private String name;\n    private Double price;\n    private String unit;\n}\n</code></pre>"},{"location":"individual/bottlenecks/cache/#resultado","title":"Resultado","text":"<p>Ap\u00f3s essas mudan\u00e7as, o cache come\u00e7ou a \u201cpegar\u201d corretamente. Ao fazer requisi\u00e7\u00f5es ao endpoint <code>GET /product/{id}</code> logo na primeira chamada o Redis ainda n\u00e3o tinha o valor, e nas chamadas seguintes o Redis respondeu, conforme monitorei com:</p> <pre><code>kubectl exec -it deploy/redis -- redis-cli MONITOR\n</code></pre> <p>Exemplos de comandos observados:</p> <pre><code>GET products::all\nSET products::all [bytes serializados]\nGET products::a045edae-794f-4e53-a2ea-562b68ea01c9\nSET products::a045edae-794f-4e53-a2ea-562b68ea01c9 [bytes serializados]\n</code></pre> <p>E o <code>kubectl get pods</code> mostra o Redis rodando ao lado dos demais servi\u00e7os:</p> <pre><code>NAME                         READY   STATUS    RESTARTS   AGE\naccount-68c6c5b66f-vtv82     1/1     Running   0          24m\nauth-6dd6bcd966-vlmls        1/1     Running   0          24m\ngateway-7ffd75cf9d-hjqkf     1/1     Running   0          24m\norder-8578847bb6-qj6cd       1/1     Running   0          24m\nproduct-5cf9d54c89-xfz94     1/1     Running   0          24m\npostgres-86d6bb...           1/1     Running   0          20m\nredis-66c4bb97fd-jrv9w       1/1     Running   0          24m\n</code></pre>"},{"location":"individual/bottlenecks/grafana-prometheus/","title":"Prometheus &amp; Grafana","text":"<p>Implementamos uma solu\u00e7\u00e3o de observabilidade no Gateway Service utilizando Prometheus e Grafana para monitorar m\u00e9tricas de todos os microservi\u00e7os em tempo real. Em resumo: - Prometheus coleta e armazena m\u00e9tricas (como uso de CPU, mem\u00f3ria, lat\u00eancias, taxa de requisi\u00e7\u00f5es) expostas pelos servi\u00e7os via endpoints Actuator/metrics e Prometheus. - Grafana consome esses dados para criar dashboards interativos, permitindo visualizar tend\u00eancias, alertas e identificar gargalos (bottlenecks).</p> <p>No nosso contexto, habilitamos o Spring Boot Actuator e o registro de m\u00e9tricas em Prometheus no Gateway Service. Assim, todas as rotas trafegam pelo gateway e suas m\u00e9tricas s\u00e3o expostas para coleta pelo Prometheus.</p>"},{"location":"individual/bottlenecks/grafana-prometheus/#arquivos-modificados","title":"Arquivos Modificados","text":""},{"location":"individual/bottlenecks/grafana-prometheus/#1-pomxml-gateway-service","title":"1. <code>pom.xml</code> (Gateway Service)","text":"<p>Adicionamos as depend\u00eancias para Actuator e Micrometer (prometheus):</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"individual/bottlenecks/grafana-prometheus/#2-docker-composeyml","title":"2. <code>docker-compose.yml</code>","text":"<p>Inclu\u00edmos os servi\u00e7os do Prometheus e Grafana:</p> <pre><code>services:\n  prometheus:\n    image: prom/prometheus:latest\n    hostname: prometheus\n    ports:\n      - 9090:9090\n    volumes:\n      - $VOLUME/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml\n\n  grafana:\n    image: grafana/grafana-enterprise\n    hostname: grafana\n    ports:\n      - 3000:3000\n    environment:\n      - GF_SECURITY_ADMIN_PASSWORD=admin\n    volumes:\n      - $VOLUME/grafana:/var/lib/grafana\n      - $VOLUME/grafana/provisioning/datasources:/etc/grafana/provisioning/datasources\n    depends_on:\n      - prometheus\n</code></pre>"},{"location":"individual/bottlenecks/grafana-prometheus/#3-applicationyml-gateway-service","title":"3. <code>application.yml</code> (Gateway Service)","text":"<p>Configuramos o Actuator e o endpoint de m\u00e9tricas para Prometheus:</p> <pre><code>server:\n  port: 8080\n\nspring:\n  application:\n    name: gateway\n\n  cloud:\n    gateway:\n      routes:\n        - id: account\n          uri: http://account:8080\n          predicates:\n            - Path=/account/**\n        - id: auth\n          uri: http://auth:8080\n          predicates:\n            - Path=/auth/**\n        - id: exchange\n          uri: http://exchange:80\n          predicates:\n            - Path=/exchange/**\n        - id: product\n          uri: http://product:8080\n          predicates:\n            - Path=/product/**\n        - id: order\n          uri: http://order:8080\n          predicates:\n            - Path=/order/**\n\nlogging:\n  level:\n    store: ${LOGGING_LEVEL_STORE:debug}\n\nmanagement:\n  endpoint:\n    gateway:\n      enabled: true\n  endpoints:\n    web:\n      base-path: /gateway/actuator\n      exposure:\n        include: ['prometheus', 'gateway']\n</code></pre> <p>Com essa configura\u00e7\u00e3o, o Gateway exp\u00f5e m\u00e9tricas em <code>/gateway/actuator/prometheus</code>.</p>"},{"location":"individual/bottlenecks/grafana-prometheus/#capturas-de-tela","title":"Capturas de Tela","text":"<p>Abaixo, algumas evid\u00eancias dos servi\u00e7os em execu\u00e7\u00e3o e do monitoramento:</p> <ul> <li> <p>Containers Docker rodando </p> </li> <li> <p>Pods no Kubernetes (incluindo Redis e Grafana) </p> </li> </ul>"},{"location":"individual/bottlenecks/grafana-prometheus/#como-funciona","title":"Como Funciona","text":"<ol> <li>O Prometheus est\u00e1 configurado para \u201cscrape\u201d o endpoint <code>/gateway/actuator/prometheus</code> do servi\u00e7o gateway.  </li> <li>Todas as m\u00e9tricas (lat\u00eancias de rotas, contagem de requisi\u00e7\u00f5es, status HTTP) s\u00e3o coletadas periodicamente.</li> <li>O Grafana foi configurado para usar o Prometheus como fonte de dados, exibindo dashboards com gr\u00e1ficos de performance e alertas.</li> </ol> <p>Dessa forma, conseguimos identificar eventuais bottlenecks (por exemplo, rota com alta lat\u00eancia ou uso elevado de CPU) e tomar a\u00e7\u00f5es pr\u00f3-ativas.</p>"}]}